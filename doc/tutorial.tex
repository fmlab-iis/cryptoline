\documentclass{amsproc}

\usepackage{xspace}
\usepackage{amssymb,amsmath,amsfonts,amsthm}
\usepackage{url}
\usepackage{subcaption}
\usepackage[margin=1.25in]{geometry}
%\usepackage{tabularray}

\input{macro}

\begin{document}

\title{\cryptoline: A Tutorial}
\author{Jiaxiang Liu}
\author{Xiaomu Shi}
\author{Ming-Hsien Tsai}
\author{Bow-Yaw Wang}
\author{Bo-Yin Yang}
\date{\today}
\maketitle

\section{Introduction}

\cryptoline is a verification tool chain for cryptographic assembly
programs. It contains the \cryptoline model checker and tools for
building models from executable binary codes. \cryptoline is designed
for verifying algebraic properties in cryptographic programs. It has
been used to verify cryptographic assembly programs in \openssl and
\blst, \pqclean, and \pqmfour.

In this tutorial, we explain notable features of \cryptoline through
two running examples from \xeightysix implementations for NIST P-256 curve
in \openssl. Specifically, NIST P-256 curve uses the finite field
$\mZ_{p256}$ where $p256$ is
\[
\mathtt{0xffffffff00000001\ 0000000000000000\ 00000000ffffffff\ 
   ffffffffffffffff}.
\]
We will verify the addition (\texttt{ecp\_nistz256\_add})
and Montegomery multiplication (\texttt{ecp\_nistz256\_mul\_montx})
over the field $\mZ_{p256}$ from \texttt{crypto/ec/asm} in \openssl.
All \cryptoline codes can be found in
\texttt{examples/openss/ecp\_nistz256/\xeightysix} from the \cryptoline
distribution. 

\section{\cryptoline Overview}

To verify cryptographic programs with \cryptoline, a verifier has to
construct program models written in the \cryptoline language. Such
program models could be written manually. Manual construction
nevertheless could be tedious or even deviant from real cryptographic
programs. To help verifiers, \cryptoline provides a \python script
\itrace to extract traces from running cryptographic
programs in \gdb. Verifiers will obtain traces of cryptographic 
programs as executed on hardware. Since traces are extracted from
\gdb, they are sequences of assembly instructions from the underlying
hardware architecture. To convert such traces to \cryptoline models,
\cryptoline provides another \python script \tozdsl to
help verifiers translate assembly instructions to \cryptoline
commands. Through \itrace and \tozdsl, accurate \cryptoline models can
be constructed rather easily. They are indispensable in practice.

Based on the \cryptoline models generated by \tozdsl, verifiers need to
annotate models with input assumptions (or \emph{pre-conditions}) and
output requirements (or \emph{post-conditions}). Additional
annotations are often required to guide \cryptoline verification
engines as well. After necessary annotations are added, the \cryptoline
verification tool will prove if all post-conditions must hold under
pre-conditions automatically. If \cryptoline fails to prove
post-conditions, hints can be found in \cryptoline log files.
Verifiers can decide whether more annotations are needed or bugs are
found from the hints.

The \cryptoline verification tool employs two engines for proving
different properties about \cryptoline models. The SMT-based engine
calls an external SMT QFBV (Satisfiability Modulo Quantifier-Free
Bit-Vector Theory) solver to prove range properties. The CAS-based
engine calls an external CAS (Computer Algebra System) to prove
algebraic properties. Generally, the SMT-based engine is automatic but
unsuitable for complex non-linear algebraic properties. The CAS-based
engine on the other hand is much better for algebraic properties but
requires more annotations. Verifiers need to choose which engine to
use by their discretion. 

\section{Installing \cryptoline}

\cryptoline is an open-sourced project available at
\url{https://github.com/fmlab-iis/cryptoline}. To download its source
code, type
\begin{verbatim}
$ git clone https://github.com/fmlab-iis/cryptoline.git
\end{verbatim}

\cryptoline is written in \ocaml and requires the \ocaml package
manager \opam, external SMT solvers, and CAS's. Use the following
commands to install the \opam package manager, the SMT solver
\boolector, and the CAS \singular in \ubuntu:
\begin{verbatim}
$ sudo apt-get install opam boolector singular-ui 
\end{verbatim}

Additional \ocaml libraries are needed to compile \cryptoline. To
initialize \opam and install these libraries, use the following
commands:
\begin{verbatim}
$ opam init --disable-sandboxing    # initialize opam
$ eval $(opam env)                  # set up environment variables
$ opam install dune lwt_ppx zarith  # install additional OCaml packages
\end{verbatim}

Finally, go to the \cryptoline directory and compile it with the
following commands:
\begin{verbatim}
$ cd cryptoline
$ dune build
\end{verbatim}

The built \cryptoline binaries are in the \texttt{\_build/\_default}
directory. To make a symbolic link for convenience and check if
everything works fine, try
\begin{verbatim}
$ ln -s _build/default/cv.exe
$ cv.exe -v -isafety examples/openssl/ecp_nistz256/ecp_nistz256_mul_mont.cl
\end{verbatim}

If you see messages similar to the following, you are all set!
\begin{verbatim}
Parsing Cryptoline file:                [OK]            0.002074 seconds
Checking well-formedness:               [OK]            0.000732 seconds
Transforming to SSA form:               [OK]            0.000278 seconds
Normalizing specification:              [OK]            0.000017 seconds
Rewriting assignments:                  [OK]            0.000229 seconds
Verifying program safety:
         Cut 0
             Round 1 (32 safety conditions, timeout = 300 seconds)
                 Safety condition #3    [OK]
                 Safety condition #4    [OK]
                 Safety condition #0    [OK]
                 ...
                 Safety condition #28   [OK]
                 Safety condition #31   [OK]
         Overall                        [OK]            5.185277 seconds
Verifying range specification:          [OK]            2.155957 seconds
Rewriting value-preserved casting:      [OK]            0.000023 seconds
Verifying algebraic specification:      [OK]            0.107180 seconds
Verification result:                    [OK]            7.452392 seconds 
\end{verbatim}

\section{Running Examples from \openssl}

The \cryptoline verification tool is a model checker. That is, it
checks specified properties about models. To verify cryptographic
programs with \cryptoline, we need to write a model for the program
and specify properties about the model. In this tutorial, we will
verify the \xeightysix assembly subroutines \texttt{ecp\_nistz256\_add}
and \texttt{\_\_ecp\_nistz256\_mul\_montx} from
\texttt{ecp\_nistz256-x86\_64.pl} in \texttt{crypto/ec/asm} from
\openssl. The subroutine \texttt{ecp\_nistz256\_add} takes two inputs
$a$ and $b$ from the field $\mZ_{p256}$, computes their sum $c \equiv
a + b \mod p256$, and stores $c$ in memory. The API for
\texttt{\_\_ecp\_nistz256\_mul\_montx} takes two inputs $a, b$ from
$\mZ_{p256}$, computes their Montgomery product $c \equiv a \times b
\times 2^{-256} \mod p256$, and stores $c$ in memory. They are used by
\openssl on \xeightysix by default. We will see important features of
\cryptoline in these running examples.

\subsection{\nistzadd}

\subsubsection{Model Construction}

The easiest way to construct accurate \cryptoline models is by
extracting traces from execution. To do so, we need to build an
executable binary for the cryptographic program under
verification. Let us write a simple C program which calls the two
assembly subroutines.
\begin{verbatim}
#include <stdint.h>
#define P256_LIMBS 4

typedef uint64_t BN_ULONG;

/* Modular add: res = a+b mod P   */
void ecp_nistz256_add(BN_ULONG res[P256_LIMBS],
                      const BN_ULONG a[P256_LIMBS],
                      const BN_ULONG b[P256_LIMBS]);
/* Montgomery mul: res = a*b*2^-256 mod P */
void ecp_nistz256_mul_mont(BN_ULONG res[P256_LIMBS],
                           const BN_ULONG a[P256_LIMBS],
                           const BN_ULONG b[P256_LIMBS]);

int main (void) {
  BN_ULONG a[P256_LIMBS], b[P256_LIMBS], r[P256_LIMBS];
  
  /* Modular add: res = a+b mod P   */
  ecp_nistz256_add(r, a, b);
  /* Montgomery mul: res = a*b*2^-256 mod P */
  ecp_nistz256_mul_mont(r, a, b);

  return 0;
}
\end{verbatim}

An executable binary can be built with the following command
(\texttt{libcrypto.a} is from \openssl):
\begin{verbatim}
$ gcc -o top top.c libcrypto.a
\end{verbatim}

\cryptoline provides the \python script \itrace to extract execution
traces from \gdb. Write \cryptolinehome for the root directory of
\cryptoline. The execution trace of \nistzadd is extracted with the
following command:
\begin{verbatim}
$ $CL_HOME/scripts/itrace.py top ecp_nistz256_add ecp_nistz256_add.gas
\end{verbatim}
The first argument is the name of the executable binary \texttt{top},
the second argument is the name of the subroutine \nistzadd, and the
third argument is the name of the output file
(\nistzaddgas). The content of \nistzaddgas looks like
\begin{verbatim}
ecp_nistz256_add:
# %rdi = 0x7fffffffda00
# %rsi = 0x7fffffffd9c0
# %rdx = 0x7fffffffd9e0
# %rcx = 0x7fffffffd9c0
# %r8  = 0x555555580c70
# %r9  = 0x7ffef3ff00000000
	#! -> SP = 0x7fffffffd9b8
	push   %r12                       #! EA = L0x7fffffffd9b0; ...
	push   %r13                       #! EA = L0x7fffffffd9a8; ...
	mov    (%rsi),%r8                 #! EA = L0x7fffffffd9c0; ...
	xor    %r13,%r13                  #! PC = 0x55555557c327
	mov    0x8(%rsi),%r9              #! EA = L0x7fffffffd9c8; ...
	mov    0x10(%rsi),%r10            #! EA = L0x7fffffffd9d0; ...
	mov    0x18(%rsi),%r11            #! EA = L0x7fffffffd9d8; ...
	lea    -0x33d(%rip),%rsi          # 0x55555557c000 ...
	add    (%rdx),%r8                 #! EA = L0x7fffffffd9e0; ...
	adc    0x8(%rdx),%r9              #! EA = L0x7fffffffd9e8; ...
        ...
\end{verbatim}
The script \itrace shows the register contents when \nistzadd is
called. By calling convention, \texttt{\%rdi}, \texttt{\%rsi}, and
\texttt{\%rdx} contains the values of the first three arguments to
\nistzadd. In this case, we see the pointers \texttt{r[]},
\texttt{a[]}, and \texttt{b[]} are \texttt{0x7fffffffda00}, 
\texttt{0x7fffffffd9c0}, and \texttt{0x7fffffffd9e0}
respectively. For each instruction, \itrace moreover reports the
effective address of its argument (\texttt{EA}), the value stored in
the address (\texttt{Value}), and the program counter (\texttt{PC}). 
The \itrace script is necessarily architecture-dependent. It currently
supports ARM, MIPS, RISC-V, and x86. It can also connect to remote
\gdb through a serial port. It has been used to extract traces from
ARM Cortex-M4 development boards.

Our next step is to convert \xeightysix instructions to corresponding
\cryptoline commands. \cryptoline provides the \python script \tozdsl
to convert instructions by writing translation rules. Translation
rules are specified in the beginning of execution traces
(\nistzaddgas). They must start with \texttt{\#\!}. For \tozdsl,
strings prefixed by \texttt{\%\%} are matched differently. We start
with rules for such strings:
\begin{verbatim}
#! $1c(%rdi) = %%EA
#! (%rdi) = %%EA
#! $1c(%rsi) = %%EA
#! (%rsi) = %%EA
#! $1c(%rdx) = %%EA
#! (%rdx) = %%EA
#! %r$1c = %%r$1c
#! %rax = %%rax
#! %rcx = %%rcx
#! %rdx = %%rdx
\end{verbatim}
The left-hand side denotes the string in the trace to be matched. The
right-hand side denotes how to rewrite the match strings. The notations
\texttt{\$1c}, \texttt{\$2c}, and so on match constants. The first six
rules rewrite memory references to \texttt{\%\%EA}. The last four
rules add an additional \texttt{\%} to registers.

For each \xeightysix instruction in \nistzaddgas, a translation rule is
needed for convertion. Instructions starting with \texttt{\#} will be
skipped. Let us look at the rule for the \xeightysix \texttt{xor} instruction:
\begin{verbatim}
#! xor $1v, $1v -> mov $1v 0@uint64
\end{verbatim}
The left-hand side denotes the pattern in the trace to be matched. The
right-hand side denotes how to rewrite the matched pattern. The strings
prefixed with \texttt{\%\%} are matched by \texttt{\$1v},
\texttt{\$2v}, and so on. The \xeightysix instructions from the trace
separate arguments by \texttt{,}. They moreover write sources before
destinations. The \cryptoline commands however write destinations
before sources. In this rule, the same register appears in both
arguments to the \texttt{xor} instruction. The register is set to
zero effectively. The rule thus sets the \cryptoline variable to
\texttt{0@uint64}. Note that all constants in \cryptoline must be
given a type. The notation \texttt{0@uint64} denotes the constant zero
of the unsigned 64-bit integer type.

Our next rules are for the \xeightysix \texttt{mov} instruction:
\begin{verbatim}
#! mov $1v, $2v -> mov $2v $1v
#! mov $1ea, $2v -> mov $2v $1ea
#! mov $1v, $2ea -> mov $2ea $1v
\end{verbatim}
The string \texttt{\%\%EA} is matched by \texttt{\$1ea},
\texttt{\$2ea}, and so on. Recall that \itrace reports the effective
address appeared in each instruction. The script \tozdsl will also
rewrite each matched \texttt{\%\%EA} to the corresponding effective
address. In \cryptoline, there is no memory model. All memory stores
are modeled by \cryptoline variables. By convention, the memory store
with the address \texttt{\textit{addr}} are modeled by the variable 
\texttt{L\textit{addr}}. Using effective addresses as variable names
allows us to avoid tedious address computation. It greatly simplifies
our model construction. Our rules simply swap the order of source and
destination.

The rules for arithmetic instructions are also straightforward:
\begin{verbatim}
#! add $1ea, $2v -> adds carry $2v $2v $1ea
#! adc $1ea, $2v -> adcs carry $2v $2v $1ea carry
#! adc \$0x0, $1v -> adc $1v $1v 0@uint64 carry
#! sub $1ea, $2v -> subb carry $2v $2v $1ea
#! sbb $1ea, $2v -> sbbs carry $2v $2v $1ea carry
#! sbb \$0x0, $1v -> sbbs carry $1v $1v 0@uint64 carry
\end{verbatim}
In \cryptoline commands, all arguments are explicit. Consider, for
instance, the \xeightysix \texttt{add} instruction. It puts the sum of the
two arguments in the destination \emph{and} sets the carry flag
implicitly. In \cryptoline, two commands are provided for addition:
\texttt{add} updates the destination with the sum of sources;
\texttt{adds} updates the destination with the sume of sources
\emph{and} the destination flag with carry. In our rules, the
\cryptoline variable \texttt{carry} denotes the carry flag. We
therefore use the \texttt{adds} and \texttt{adcs} for the \xeightysix
\texttt{add} and \texttt{adc} instructions respectively. Finally,
\cryptoline provides subtraction commands for carry or borrow
flags. The \texttt{subb} commands updates the destination with the
difference of sources and the destination flag with \emph{borrow}; the
\texttt{subc} commands updates the destination with the difference of
sources and the destination flag with \emph{carry}. In \xeightysix, the
\texttt{sub} instruction updates the carry flag with borrow. Our rule
hence uses the \cryptoline \texttt{subb} command.

Our last rule is for the \xeightysix \texttt{cmovb} instruction:
\begin{verbatim}
#! cmovb $1v, $2v -> cmov $2v carry $1v $2v
\end{verbatim}
The instruction sets the destination to the value of source if the
carry flag is true. The \cryptoline command \texttt{cmov} sets the
destination to the value of the first source if the source flag is
true; it sets the destination to the value of the second source
otherwise.

After putting all translation rules in the beginning of \nistzaddgas,
the \xeightysix trace can be converted to a \cryptoline model with
following command:
\begin{verbatim}
$ $CL_HOME/script/to_zdsl.py ecp_nistz256_add.gas > ecp_nistz256_add.cl
\end{verbatim}

The content of \nistzaddcl looks like:
\begin{verbatim}
proc main (L0x55555557c000, ...) =
{
  true
  &&
  true
}

(* #! -> SP = 0x7fffffffd9b8 *)
#! 0x7fffffffd9b8 = 0x7fffffffd9b8;
(* #push   %r12                     #! ...                       *)
#push   %%r12                       #! ...
(* #push   %r13                     #! ...                       *)
#push   %%r13                       #! ...
(* mov    (%rsi),%r8                #! EA = L0x7fffffffd9c0; ... *)
mov r8 L0x7fffffffd9c0;
(* xor    %r13,%r13                 #! PC = 0x55555557c327 *)
mov r13 0@uint64;
...
(* #repz retq                       #! PC = 0x55555557c39c *)
#repz retq                          #! ...

{
  true
  &&
  true
}
\end{verbatim}
The notation \texttt{proc main (...) =} denotes the main subroutine in
\cryptoline. The arguments to the main subroutine are the
uninitialized variables reported by \tozdsl. In this case, they are
memory stores for input arguments and constants used in \nistzadd. The
expression in the brackets \texttt{true \&\& true} denote the
pre-condition. It is followed by \cryptoline commands for \xeightysix
instructions. Each \xeightysix instruction is put in \cryptoline
comments prefixed by \texttt{\#} or enclosed by \texttt{(*} and
\texttt{*)}. It is then followed by the \cryptoline command generated
with the translation rules. Finally, the expression in the ending
brackets \texttt{true \&\& true} denotes the post-condition.

Let us first make arguments more readable by replacing the main
subroutine declaration with:
\begin{verbatim}
proc main (uint64 a0, uint64 a1, uint64 a2, uint64 a3,
           uint64 b0, uint64 b1, uint64 b2, uint64 b3,
           uint64 m0, uint64 m1, uint64 m2, uint64 m3) =
\end{verbatim}
We will use \texttt{a}'s and \texttt{b}'s for the two input elements
and \texttt{m}'s for the modulo $p256$. The pre-condition for the main
subroutine is
\begin{verbatim}
{
  true
  &&
  and [ m0 = 0xffffffffffffffff@64, m1 = 0x00000000ffffffff@64,
        m2 = 0x0000000000000000@64, m3 = 0xffffffff00000001@64,
        limbs 64 [a0, a1, a2, a3] <u limbs 64 [m0, m1, m2, m3],
        limbs 64 [b0, b1, b2, b3] <u limbs 64 [m0, m1, m2, m3]
  ]
}
\end{verbatim}
Recall that two different engines are employed in \cryptoline. In
order to differentiate properties passed to different engines, all
\cryptoline properties are of the form \texttt{\textit{P} \&\&
\textit{Q}}: \textit{P} is passed to CAS's and \textit{Q} is to SMT
solvers. For \nistzadd, the SMT-based engine suffices because it does
not involve non-linear computation. Our pre-condition simply passes
\texttt{true} to the CAS-based engine. For the SMT-based engine, the
pre-condition assumes \texttt{m}'s to be the modulo $p256$. The field
elements \texttt{a}'s and \texttt{b}'s moreover are less than $p256$
in the unsigned representation. The expression $\mathtt{limbs}\ n\
[a_0, a_1, \ldots, a_m]$ is short for
\[
  a_0\times 2^{0\times n}+a_1\times 2^{1\times n}+\cdots+a_m\times
  2^{m\times n}.
\]

Our next step is to put input field elements and constants to
correspond memory stores. By consulting \nistzaddgas, we add the
following \cryptoline commands after the pre-condition:
\begin{verbatim}
mov L0x7fffffffd9c0 a0; mov L0x7fffffffd9c8 a1;
mov L0x7fffffffd9d0 a2; mov L0x7fffffffd9d8 a3;

mov L0x7fffffffd9e0 b0; mov L0x7fffffffd9e8 b1;
mov L0x7fffffffd9f0 b2; mov L0x7fffffffd9f8 b3;

mov L0x55555557c000 0xffffffffffffffff@uint64;
mov L0x55555557c008 0x00000000ffffffff@uint64;
mov L0x55555557c010 0x0000000000000000@uint64;
mov L0x55555557c018 0xffffffff00000001@uint64;
\end{verbatim}

At the end of \nistzaddcl, we copy the result from memory stores by
the following command:
\begin{verbatim}
mov c0 L0x7fffffffda00; mov c1 L0x7fffffffda08;
mov c2 L0x7fffffffda10; mov c3 L0x7fffffffda18;
\end{verbatim}

Finally, we specify the post-condition for the SMT-based engine:
\begin{verbatim}
{
  true && 
  and [ eqmod limbs 64 [c0, c1, c2, c3, 0@64]
              limbs 64 [a0, a1, a2, a3, 0@64] + 
              limbs 64 [b0, b1, b2, b3, 0@64]
              limbs 64 [m0, m1, m2, m3, 0@64],
        limbs 64 [c0, c1, c2, c3] <u limbs 64 [m0, m1, m2, m3] ]
}
\end{verbatim}
The post-condition states that the output field element \texttt{c}'s
is congruent to the sum of input field elements modulo $p256$, and the
output field element is less than the modulo in the unsigned
representation. Note that the congruence is computed with $5\times
64=320$ bits instead of $256$ bits.

\subsubsection{Verification}

We are ready to verify our \cryptoline model for \nistzadd. Try
\begin{verbatim}
$ $CL_HOME/cv.exe -v -isafety ecp_nistz256_add.cl
\end{verbatim}
The transcript is shown below:
\begin{verbatim}
Parsing Cryptoline file:                [OK]            0.001247 seconds
Checking well-formedness:               [OK]            0.000218 seconds
Transforming to SSA form:               [OK]            0.000105 seconds
Normalizing specification:              [OK]            0.000097 seconds
Rewriting assignments:                  [OK]            0.000122 seconds
Verifying program safety:
         Cut 0
             Round 1 (1 safety conditions, timeout = 300 seconds)
                 Safety condition #0    [OK]
         Overall                        [OK]            0.044187 seconds
Verifying range specification:          [OK]            2.203067 seconds
Rewriting value-preserved casting:      [OK]            0.000023 seconds
Verifying algebraic specification:      [OK]            0.000412 seconds
Verification result:                    [OK]            2.249944 seconds
\end{verbatim}

Congratulations! You have verified the \xeightysix \nistzadd
subroutine in \openssl successfully. As we have seen, \cryptoline
provides useful scripts for model construction. They are not perfect
and still require human intervention. Some practices will help
verifiers get familiar with the verification flow.

\exercise Construct a model for \texttt{ecp\_nistz256\_sub} in 
\texttt{ecp\_nistz256-x86\_64.pl} and verify it.

\subsection{\nistzmul}

Our next example is to verify the assembly subroutine \nistzmul from
\openssl.\footnote{Depending on the 
\xeightysix microarchitecture, the assembly subroutine \nistzmul
has two implementations: \texttt{\_\_ecp\_nistz256\_mul\_montx} and
\texttt{\_\_ecp\_nistz256\_mul\_montq}. We will verify
\texttt{\_\_ecp\_nistz256\_mul\_montx} here.} The assembly subroutine
takes two field elements $a$ and $b$ in $\mZ_{p256}$ as inputs,
computes their Montgomery product $c$, and store $c$ in
memory. Mathematically, the inputs and output satisfy the following
modular equation:
\[
c \equiv a \times b \times 2^{-256} \mod p256, \textmd{
  equivalently}, 
c \times 2^{256} \equiv a \times b \mod p256
\]

\subsubsection{Model Construction}

The executable binary
\texttt{top} built in the first example also calls the assembly
subroutine. The trace for \nistzmul can be extracted by \itrace with
the same binary:
\begin{verbatim}
$ $CL_HOME/scripts/itrace.py top ecp_nistz256_mul_mont ecp_nistz256_mul_mont.gas
\end{verbatim}

The trace \nistzmulgas looks like the following:
\begin{verbatim}
ecp_nistz256_mul_mont:
# %rdi = 0x7fffffffd9f0
# %rsi = 0x7fffffffd9b0
# %rdx = 0x7fffffffd9d0
# %rcx = 0x7fffffffd9b0
# %r8  = 0x-9
# %r9  = 0xfffffffe
	#! -> SP = 0x7fffffffd9a8
	mov    $0x80100,%ecx            #! PC = 0x55555557d1e0
	and    0x5e35(%rip),%ecx        # ...
	push   %rbp                     #! EA = L0x7fffffffd9a0; ...
	push   %rbx                     #! EA = L0x7fffffffd998; ...
        ...
\end{verbatim}
By calling convention, we know the input field elements are stored at
\texttt{0x7fffffffd9b0} and \texttt{0x7fffffffd9d0}; the output is
stored at \texttt{0x7fffffffd9f0}. The subroutine uses more
registers. Unsurprisingly, we need additional translation rules for
memory addresses and registers.
\begin{verbatim}
#! $1c(%rdi) = %%EA
#! (%rdi) = %%EA
#! $1c(%rsi) = %%EA
#! (%rsi) = %%EA
#! $1c(%rdx) = %%EA
#! (%rdx) = %%EA
#! $1c(%rbx) = %%EA
#! (%rbx) = %%EA
#! -$1c(%rip) = %%EA
#! %r$1c = %%r$1c
#! %rax = %%rax
#! %rbx = %%rbx
#! %rcx = %%rcx
#! %rdx = %%rdx
#! %rbp = %%rbp
#! %eax = %%eax
\end{verbatim}

Many translation rules for \xeightysix instructions can be
re-used. They are listed below:
\begin{verbatim}
#! add $1v, $2v -> adds carry $2v $2v $1v
#! adc $1v, $2v -> adcs carry $2v $2v $1v carry
#! cmovb $1v, $2v -> cmov $2v carry $1v $2v
#! mov $1c, $2v -> mov $2v $1c@uint64
#! mov $1v, $2v -> mov $2v $1v
#! mov $1ea, $2v -> mov $2v $1ea
#! mov $1v, $2ea -> mov $2ea $1v
#! sbb $1v, $2v -> sbbs carry $2v $2v $1v carry
\end{verbatim}

Three rules are modified slightly. They are:
\begin{verbatim}
#! xor $1v, $1v -> mov $1v 0@uint64;\nclear carry;\nclear overflow
#! adc $1c, $2v -> adc $2v $2v $1c@uint64 carry
#! sbb $1c, $2v -> sbbs carry $2v $2v $1c@uint64 carry
\end{verbatim}
The \xeightysix \texttt{xor} instruction actually clears carry and
overflow flags. This is not modeled previously but needed in
\nistzmul, so the rule is modified accordingly. The string
\texttt{\\n} represents a line break. In \nistzmul, more
constant literals are used. We therefore use \texttt{\$1c} to match
constants in the rules for \texttt{adc} and \texttt{sbb}.

Two additional addition instructions are used in \nistzmul. The
\texttt{adcx} and \texttt{adox} instructions compute the sum with the
carry and overflow flags as carry respectively. Their translation
rules are similar to those for \texttt{adc}:
\begin{verbatim}
#! adcx $1v, $2v -> adcs carry $2v $2v $1v carry
#! adox $1v, $2v -> adcs overflow $2v $2v $1v overflow
\end{verbatim}

The \xeightysix \texttt{mulx} computes the product of the \texttt{rdx}
register and the source. The 128-bit product is then stored in the
destinations. The \cryptoline \texttt{mull} command computes the
product of the last two arguments, stores the more significant half
in the first argument and the less significant half in the second. We
thus use the following rule for \texttt{mulx}:
\begin{verbatim}
#! mulx $1v, $2v, $3v -> mull $3v $2v rdx $1v
\end{verbatim}

Finally, the \xeightysix instruction \texttt{shlx \textit{r}
  \textit{s} \texttt{d}} and \texttt{shrx \textit{r} \textit{s}
  \textit{d}} shifts the value of \texttt{\textit{s}} to the left and
right respectively by the value in \texttt{\textit{r}}. The shifted
result is stored in \texttt{\textit{d}}. In \cryptoline, the
\texttt{shl \textit{d} \textit{s} \textit{c}} shifts the value of
\texttt{\textit{s}} by the constant \texttt{\textit{c}} bits to the
left. The \texttt{split \textit{h} \textit{l} \textit{s} \textit{c}}
command splits \texttt{\textit{s}} by the constant \texttt{\textit{c}}
into two parts: the lowest \texttt{\textit{c}} bits are stored in
\texttt{\textit{l}} and other bits are stored in \texttt{\textit{h}}.
It is tempting to use the following rules:
\begin{verbatim}
#! shlx $1v, $2v, $3v -> shl $3v $2v $1v
#! shrx $1v, $2v, $3v -> split $3v dc $2v $1v
\end{verbatim}
There is a problem in these rules. The \texttt{shl} and
\texttt{split} commands only allow constant shifting and splitting. We
need to change the variable \texttt{\$1v} to a constant. After
examining \nistzmul, we see the first argument of all \texttt{shlx}
and \texttt{shrx} instructions is always \texttt{\%r14}. Moreover,
\texttt{\%r14} is set to \texttt{\$0x20} and never changed. We can ask
\cryptoline to check the value of \texttt{\$1v} is always 32 and then
use 32 as the shifting and splitting constant. The \cryptoline
\texttt{assert \textit{P} \&\& \textit{Q}} command checks both
\texttt{\textit{P}} and \texttt{\textit{Q}} must be true. The
verification fails if any of \texttt{\textit{P}} or
\texttt{\textit{Q}} can be false. Consider the following rules:
\begin{verbatim}
#! shlx $1v, $2v, $3v -> assert $1v=32 && true;\nshl $3v $2v 32
#! shrx $1v, $2v, $3v -> assert $1v=32 && true;\nsplit $3v dc $2v 32
\end{verbatim}
The \texttt{assert \$1v=32 \&\& true} command ensures \texttt{\$1v}
must be 32 at this location. If so, we use the constant 32 instead of
the variable \texttt{\$1v}. Note that we ask an external CAS to check
if \texttt{\$1v} is equal 32. If you would like to use the SMT-based
engine, use \texttt{assert true \&\& \$1v=32@64} instead.

The translation rule for \texttt{shlx} nevertheless would not
work. Safety conditions would fail during verification if they were
used. To explain what safety conditions are, recall that \cryptoline
employs two different engines. Every \cryptoline command therefore has
two different interpretations: one for the SMT-based, the other for
the CAS-base engine. The \texttt{shl \textit{d} \textit{s} \textit{c}}
command is interpreted as the logical left shift in bit-vector theory
in the SMT-based engine. It is interpreted by the equation 
\texttt{\textit{d}} = \texttt{\textit{s}} $\times$
$2^{\texttt{\textit{c}}}$ in the CAS-based engine. Two different
interpretations need to be related, otherwise their results may differ
unexpectedly. To relate both interpretations of \texttt{shl},
\cryptoline checks safety conditions to see if information
might be lost in the command. For \texttt{shl}, the safety condition
is that only zeros are shifted out. Thus, both interpretations
coincide. In \nistzmul, this is not the case. We need to translate the
\xeightysix \texttt{shlx} instruction differently to avoid the safety
condition failure.

Let us go back to \nistzmulgas. Consider the following rule for
\texttt{shlx}:
\begin{verbatim}
#! shlx $1v, $2v, $3v -> assert $1v=32 && true;\nsplit ddc $3v $2v 32;\nshl $3v $3v 32
\end{verbatim}
After check \texttt{\$1v} is 32, it splits \texttt{\$2v} into two. The
high 32-bit value is stored in \texttt{ddc}. The low 32-bit value in
\texttt{\$2v} is then shifted to the left by 32 bits. 

To further improve our translation rules, let us see how \texttt{shlx}
and \texttt{shrx} are used in \nistzmulgas:
\begin{verbatim}
shlx   %r14,%r8,%rbp              #! PC = 0x55555557d72e
adc    %rcx,%r11                  #! PC = 0x55555557d733
shrx   %r14,%r8,%rcx              #! PC = 0x55555557d736
\end{verbatim}
The \texttt{shlx} instruction puts the low 32-bit of \texttt{r8} in
\texttt{rbp}. Then \texttt{shrx} puts the high 32-bit of \texttt{r8}
in \texttt{rcx}. In the \cryptoline fragment, the variable
\texttt{ddc} is in fact equal to \texttt{rcx}. Let us change the rule
for \texttt{shrx} to check it. Consider the following rule:
\begin{verbatim}
#! shrx $1v, $2v, $3v -> assert $1v=32 && true;\nsplit $3v dc $2v 32;\nassert true 
&& $3v=ddc;\nassume $3v=ddc && true
\end{verbatim}
After obtaining \texttt{\$3v}, the new rule asks the SMT-based engine
to check if \texttt{\$3v} is equal to \texttt{ddc}. The equation is
then passed to the CAS-based engine by the \cryptoline \texttt{assume}
command. This is a common technique to pass information between
engines. We ask one engine to verify a property with \texttt{assert},
and then pass the property to the other engine with \texttt{assume}.

We are ready to apply the translation rules. After commenting out
irrelevant instructions in trace, use the following command:
\begin{verbatim}
$ $CL_HOME/scripts/to_zdsl.py ecp_nistz256_mul_mont.gas > ecp_nistz256_mul_mont.cl
\end{verbatim}

It remains to declare input parameters and specify properties about
\nistzmul. The declaration and pre-condition are similar to \nistzadd:
\begin{verbatim}
proc main (uint64 a0, uint64 a1, uint64 a2, uint64 a3,
           uint64 b0, uint64 b1, uint64 b2, uint64 b3,
           uint64 m0, uint64 m1, uint64 m2, uint64 m3) =
{
  and [ m0 = 0xffffffffffffffff, m1 = 0x00000000ffffffff,
        m2 = 0x0000000000000000, m3 = 0xffffffff00000001 ]
  &&
  and [ m0 = 0xffffffffffffffff@64, m1 = 0x00000000ffffffff@64,
        m2 = 0x0000000000000000@64, m3 = 0xffffffff00000001@64,
        limbs 64 [a0, a1, a2, a3] <u limbs 64 [m0, m1, m2, m3],
        limbs 64 [b0, b1, b2, b3] <u limbs 64 [m0, m1, m2, m3]
  ]
}
\end{verbatim}
Note that the modulo \texttt{m}'s appear in both parts of
pre-condition. Since we will use the CAS-based engine, we need to tell
the engine about \texttt{m}'s. Similarly, we initialize memory stores
with input parameters and constants.
\begin{verbatim}
mov L0x7fffffffd9b0 a0; mov L0x7fffffffd9b8 a1;
mov L0x7fffffffd9c0 a2; mov L0x7fffffffd9c8 a3;

mov L0x7fffffffd9d0 b0; mov L0x7fffffffd9d8 b1;
mov L0x7fffffffd9e0 b2; mov L0x7fffffffd9e8 b3;

mov L0x55555557c000 0xffffffffffffffff@uint64;
mov L0x55555557c008 0x00000000ffffffff@uint64;
mov L0x55555557c010 0x0000000000000000@uint64;
mov L0x55555557c018 0xffffffff00000001@uint64;
\end{verbatim}


At the end of \nistzmulcl, the results \texttt{c}'s are obtained from
memory stores.
\begin{verbatim}
mov c0 L0x7fffffffd9f0; mov c1 L0x7fffffffd9f8;
mov c2 L0x7fffffffda00; mov c3 L0x7fffffffda08;
\end{verbatim}
And we use the following post-condition:
\begin{verbatim}
{
  eqmod limbs 64 [0, 0, 0, 0, c0, c1, c2, c3]
        limbs 64 [a0, a1, a2, a3] * limbs 64 [b0, b1, b2, b3]
        limbs 64 [m0, m1, m2, m3]
&&
  limbs 64 [c0, c1, c2, c3] <u limbs 64 [m0, m1, m2, m3]
}
\end{verbatim}
In the post-condition, we ask the CAS-based engine to verify $c \times
2^{256} \equiv a \times b \mod p256$. For the range check $c < p256$,
we employs the SMT-based engine.

\subsubsection{Verification}

We are ready to verify our model. Type
\begin{verbatim}
$ $CL_HOME/cv.exe -v -isafety ecp_nistz256_mul_mont.cl
\end{verbatim}

\cryptoline reports the algebraic specification fails. We will add
more annotations to our model. We have seen how information can be
passed between engines in the translation rules for \texttt{shlx} and
\texttt{shrx}. Another useful information to pass from the SMT-based
to the CAS-based 
engines is addition carries. When carries propagate along long
additions, the last carry is almost always zero. Such information is
easily inferred with the SMT-based engine. In \nistzmul, two threads
of long additions are computed interleaved. One uses the
\xeightysix \texttt{adcx} instruction and the other uses
\texttt{adox}. There are three pairs of interleaving long
additions. At the end of each pair, we annotate \nistzmulcl with the
following commands:
\begin{verbatim}
(* NOTE: can't carry *)
assert true && and [carry=0@1,overflow=0@1];
assume and [carry=0,overflow=0] && true;
\end{verbatim}
Here, we ask the SMT-based engine to verify both carry and overflow
are zeros, and then pass the information to the CAS-baesd engine.

The last annotation we need to add is for the conditional moves at the
end of \nistzmul. Similar to \nistzadd, the conditional moves check if
the Montgomery product is less than $p256$ by subtraction. If not, the
difference is returned. The SMT-based engine suffices to verify this
in \nistzadd. We will verify the conditional moves in the SMT-based
engine and pass the information to the CAS-based engine. Let us save
the Montgomery product before subtraction with the following:
\begin{verbatim}
ghost r12o@uint64, r13o@uint64, r8o@uint64, r9o@uint64, r10o@uint64 :
      and [r12o=r12, r13o=r13, r8o=r8, r9o=r9, r10o=r10]
   && and [r12o=r12, r13o=r13, r8o=r8, r9o=r9, r10o=r10];
\end{verbatim}
The keyword \texttt{ghost} declares five reference variables
\texttt{r12o}, \texttt{r13o}, \texttt{r8o}, \texttt{r9o}, and
\texttt{r10o}. These reference variables can only appear in
\texttt{assert} and \texttt{assume} commands and hence cannot the
computation of \nistzmul. After the conditional moves, we add two
\cryptoline commands:
\begin{verbatim}
(* NOTE: final reduction *)
assert true &&
       eqmod limbs 64 [r12, r13, r8, r9, 0@64]
             limbs 64 [r12o, r13o, r8o, r9o, r10o]
             limbs 64 [m0, m1, m2, m3, 0@64];
assume eqmod limbs 64 [r12, r13, r8, r9, 0]
             limbs 64 [r12o, r13o, r8o, r9o, r10o]
             limbs 64 [m0, m1, m2, m3, 0] && true;
\end{verbatim}
The \texttt{assert} command asks the SMT-based engine to verify the
result is congruent to the Montgomery product modulo $p256$. The
information is then passed to the CAS-based engine in
\texttt{assume}. 

Using the following command, \cryptoline reports \nistzmul
is verified:
\begin{verbatim}
$ $CL_HOME/cv.exe -v -isafety ecp_nistz256_mul_mont.cl
\end{verbatim}

\exercise Construct a model for \texttt{ecp\_nistz256\_sqr\_mont} in 
\texttt{ecp\_nistz256-x86\_64.pl} and verify it.

\subsection{Compositional Reasoning with \texttt{cut}}

The \nistzmul subroutine computes in two phases. The first phase
computes the Montgomery product and stores it in five registers
\texttt{r12}, \texttt{r13}, \texttt{r8}, \texttt{r9}, and
\texttt{r10}. The second phase reduces the Montgomery product by
modulo $p256$ and stores the final result in four registers
\texttt{r12}, \texttt{r13}, \texttt{r8}, and \texttt{r9}. Since the
two phases appear to be independent, they may be verified
independently. 

The \cryptoline \texttt{cut \textit{P} \&\& \textit{Q}} command
provides a simple mechanism to divide a verification task by
parts. Consider the \cryptoline model in
Figure~\ref{figure:cut:original}. The \texttt{cut} command effectively
splits the model into three parts shown in Figure~\ref{figure:cut:i}
to \ref{figure:cut:ii}. Observe that \texttt{P1 \&\& Q1} is the
post-condition in Figure~\ref{figure:cut:i} but the pre-condition in
Figure~\ref{figure:cut:ii}. Similarly, \texttt{P2 \&\& Q2} is the
post-condition in Figure~\ref{figure:cut:ii} but the pre-condition in
Figure~\ref{figure:cut:iii}. \cryptoline reports successful
verification when all three parts are verified successfully.
Informally, \texttt{P1 \&\& Q1} is established and then assumed to
verify \texttt{P2 \&\& Q2}. \texttt{P2 \&\& Q2} is then assumed to
prove \texttt{P3 \&\& Q3}. If we know how to divide a large
cryptographic program into phases, the \texttt{cut} command allows us
to verify the program by parts.

\begin{figure}
  \centering
  \begin{subfigure}{.24\columnwidth}
\begin{verbatim}
proc main (...) =
{ P0 && Q0 }
(* Phase I *)
cut P1 && Q1;
(* Phase II *)
cut P2 && Q2:
(* Phase III *)
{ P3 && Q3 }
\end{verbatim}
  \caption{Original}
  \label{figure:cut:original}
  \end{subfigure}
  \begin{subfigure}{.24\columnwidth}
\begin{verbatim}
proc main0 (...) =
{ P0 && Q0 }
(* Phase I *)
{ P1 && Q1 }




\end{verbatim}
  \caption{Part I}
  \label{figure:cut:i}
  \end{subfigure}
  \begin{subfigure}{.24\columnwidth}
\begin{verbatim}
proc main1 (...) =
{ P1 && Q1 }
(* Phase II *)
{ P2 && Q2 }




\end{verbatim}
  \caption{Part II}
  \label{figure:cut:ii}
  \end{subfigure}
  \begin{subfigure}{.24\columnwidth}
\begin{verbatim}
proc main2 (...) =
{ P2 && Q2 }
(* Phase III *)
{ P3 && Q3 }




\end{verbatim}
  \caption{Part III}
  \label{figure:cut:iii}
  \end{subfigure}
  \caption{The \cryptoline \texttt{cut} Command}
  \label{figure:cut}
\end{figure}

Back to \nistzmul, it is natural to divide the subroutine by its two
phases. Let us add the following command just before the
\texttt{ghost} declaration:
\begin{verbatim}
cut eqmod limbs 64 [0, 0, 0, 0, r12, r13, r8, r9, r10]
          (limbs 64 [a0, a1, a2, a3] * limbs 64 [b0, b1, b2, b3])
          limbs 64 [m0, m1, m2, m3] &&
    and [limbs 64 [r12, r13, r8, r9, r10] <u
         2@320 * limbs 64 [m0, m1, m2, m3, 0@64],
         m0 = 0xffffffffffffffff@64, m1 = 0x00000000ffffffff@64,
         m2 = 0x0000000000000000@64, m3 = 0xffffffff00000001@64,
         r14=0x00000000ffffffff@64, r15=0xffffffff00000001@64,
         r12=rbx, r13=rdx];
\end{verbatim}
The \texttt{cut} command states the Montgomery product is stored in
the five registers \texttt{r12}, \texttt{r13}, \texttt{r8},
\texttt{r9}, and \texttt{r10} and the product is less than twice of
the modulo. The remaining equations collect necessary assumptions to
verify the reduction modulo $p256$.

With the simple modification, we can verify \nistzmulcl again:
\begin{verbatim}
$ $CL_HOME/cv.exe -v -isafety ecp_nistz256_mul_mont.cl
\end{verbatim}
On Raspberry Pi 4 (1.8GHz ARM Cortex-A72 with 8GB RAM), the model
without \texttt{cut} is verified in 153 seconds. In contrast, the
model with \texttt{cut} is verified in 52 seconds. The \texttt{cut}
command can significantly reduce the verification time if used
properly.

\exercise Add \texttt{cut} to your model for
\texttt{ecp\_nistz256\_sqr\_mont} and compare verification time.

\end{document}

