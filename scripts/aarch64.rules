# address patterns

#! [sp, $1c]! = %%EA
#! [sp, $1c] = %%EA
#! [sp], $1c = %%EA
#! [sp] = %%EA
#! [x$1c, $2c] = %%EA
#! [x$1c], $2c = %%EA
#! [x$1c] = %%EA

# registers

#! sp = %%sp
#! v$1c = %%v$1c
#! w$1c = %%w$1c
#! x$1c = %%x$1c

# scalar instructions

#! adc $1v, $2v, $3v -> adc $1v $2v $3v carry
#! adc $1v, $2c, $3v -> adc $1v $2c@uint64 $3v carry
#! adc $1v, $2v, $3c -> adc $1v $2v $3c@uint64 carry
#! adc $1v, $2v, xzr -> adc $1v $2v 0@uint64 carry
#! adc $1v, xzr, $2v -> adc $1v 0@uint64 $2v carry
#! adc $1v, xzr, xzr -> adc $1v 0@uint64 0@uint64 carry
#! adcs $1v, $2v, $3v -> adcs carry $1v $2v $3v carry
#! adcs $1v, $2c, $3v -> adcs carry $1v $2c@uint64 $3v carry
#! adcs $1v, $2v, $3c -> adcs carry $1v $2v $3c@uint64 carry
#! adcs $1v, $2v, xzr -> adcs carry $1v $2v 0@uint64 carry
#! add $1v, $2v, $3v -> add $1v $2v $3v
#! add $1v, $2c, $3v -> add $1v $2c@uint63 $3v
#! add $1v, $2v, $3c -> add $1v $2v $3c@uint64
#! adds $1v, $2v, $3v, lsl $4c -> split dcH $3v_t $3v `64 - $4c`; shl $3v_t $3v_t $4c; adds carry $1v $2v $3v_t
#! adds $1v, $2v, $3v, lsr $4c -> split $3v_t dcL $3v $4c; adds carry $1v $2v $3v_t
#! adds $1v, $2v, $3v -> adds carry $1v $2v $3v
#! adds $1v, $2c, $3v -> adds carry $1v $2c@uint64 $3v
#! adds $1v, $2v, $3c -> adds carry $1v $2v $3c@uint64
#! and $1v, $2v, $3v -> and $1v@uint64 $2v $3v
#! ands $1v, $2v, $3c -> and $1v@uint64 $2v $3c@uint64; subc zero dc 0@uint64 $1v
#! bic $1v, $2v, $3v -> not $3v_n@uint64 $3v; and $1v@uint64 $2v $3v_n
#! cmp $1v, xzr -> subc zero dc 0@uint64 $1v
#! csel $1v, $2v, $3v, cc  // .* -> cmov $1v carry $3v $2v
#! csel $1v, $2v, $3v, cs  // .* -> cmov $1v carry $2v $3v
#! csel $1v, $2v, $3v, eq // .*  -> cmov $1v zero $2v $3v
#! csel $1v, $2v, xzr, eq // .*  -> cmov $1v zero $2v 0@uint64
#! csel $1v, xzr, $2v, eq // .*  -> cmov $1v zero 0@uint64 $2v
#! eor $1v, $2v, $3v, lsl $4c -> split dc $3v_L $3v `64 - $4c`; shl $3v_S $3v_L $4c; xor $1v@uint64 $2v $3v_L
#! eor $1v, $2v, $3v, ror $4c -> ror $3v_R@uint64 $3v $4c; xor $1v@uint64 $2v $3v_R
#! eor $1v, $2v, $3v -> xor $1v@uint64 $2v $3v
#! extr $1v, $2v, $3v, $4c -> spl dc extr_H $2v $4c; spl extr_L dc $3v $4c; join $1v extr_H extr_L
#! ldp $1v, $2v, $3ea -> mov $1v $3ea; mov $2v $3ea[+8]
#! ldr $1v, $2ea -> mov $1v $2ea
#! ldur $1v, $2ea -> mov $1v $2ea
#! lsl $1v, $2v, $3c -> split dcH $1v $2v (64-$3c); shl $1v $1v $3c
#! lsr $1v, $2v, $3c -> split $1v dcL $2v $3c
#! mov $1v, wzr -> mov $1v 0@uint32
#! mov $1v, xzr -> mov $1v 0@uint64
#! mov $1v, $2v -> mov $1v $2v
#! mov $1v, $2c // -> mov $1v $2c@uint64
#! mov $1v, $2c -> mov $1v $2c@uint64
#! mul $1v, $2v, $3v -> mull dcH $1v $2v $3v
#! ngc $1v, $2v -> sbcs dc $1v 0@uint64 $2v carry
#! ngc $1v, xzr -> sbcs dc $1v 0@uint64 0@uint64 carry
#! ngcs $1v, $2v -> sbcs carry $1v 0@uint64 $2v carry
#! umulh $1v, $2v, $3v -> mull $1v dcL $2v $3v
#! orr $1v, $2v, $3v -> or $1v@uint64 $2v $3v
#! orr $1v, $2v, $3c -> or $1v@uint64 $2v $3c@uint64
#! orr $1v, xzr, $2c -> mov $1v $2c@uint64
#! ror $1v, $2v, $3c -> ror $1v@uint64 $2v $3c
#! sub $1v, $2v, $3v -> sub $1v $2v $3v
#! sub $1v, $2c, $3v -> sub $1v $2c@uint64 $3v
#! sub $1v, $2v, $3c -> sub $1v $2v $3c@uint64
#! subs $1v, $2v, $3v -> subc carry $1v $2v $3v
#! subs $1v, $2c, $3v -> subc carry $1v $2c@uint64 $3v
#! subs $1v, $2v, $3c -> subc carry $1v $2v $3c@uint64
#! sbc $1v, $2v, $3v -> sbc $1v $2v $3v carry
#! sbc $1v, $2c, $3v -> sbc $1v $2c@uint64 $3v carry
#! sbc $1v, $2v, $3c -> sbc $1v $2v $3c@uint64 carry
#! sbcs $1v, $2v, $3v -> sbcs carry $1v $2v $3v carry
#! sbcs $1v, $2c, $3v -> sbcs carry $1v $2c@uint64 $3v carry
#! sbcs $1v, $2v, $3c -> sbcs carry $1v $2v $3c@uint64 carry
#! sbcs $1v, $2v, xzr -> sbcs carry $1v $2v 0@uint64 carry
#! sbcs $1v, xzr, $2v -> sbcs carry $1v $2v 0@uint64 carry
#! sbcs xzr, $1v, xzr -> sbcs carry dontcare $1v 0@uint64 carry
#! stp $1v, $2v, $3ea -> mov $3ea $1v; mov $3ea[+8] $2v
#! str $1v, $2ea -> mov $2ea $1v
#! stur $1v, $2ea -> mov $2ea $1v
#! tst $1v, $2c -> and tst_t@uint64 $1v $2c@uint64; subc zero dc 0@uint64 tst_t

# vector instructions
# b = 8 bits, s = 32 bits, d = 64 bits

#! add $1v.4s, $2v.4s, $3v.4s -> adds dc $1v_0 $2v_0 $3v_0; adds dc $1v_1 $2v_1 $3v_1;\nadds dc $1v_2 $2v_2 $3v_2; adds dc $1v_3 $2v_3 $3v_3
#! eor $1v.16b, $2v.16b, $3v.16b -> xor $1v_0@uint32 $2v_0 $3v_0; xor $1v_1@uint32 $2v_1 $3v_1;\nxor $1v_2@uint32 $2v_2 $3v_2; xor $1v_3@uint32 $2v_3 $3v_3
# ext $1v.16b, $2v.16b, $3v.16b, \#4 -> mov ext_0 $3v_1; mov ext_1 $3v_2; mov ext_2 $3v_3; mov ext_3 $2v_0;\nmov $1v_0 ext_0; mov $1v_1 ext_1; mov $1v_2 ext_2; mov $1v_3 ext_3
#! ext $1v.16b, $2v.16b, $3v.16b, \#4 -> mov ext_0 $2v_1; mov ext_1 $2v_2; mov ext_2 $2v_3; mov ext_3 $3v_0;\nmov $1v_0 ext_0; mov $1v_1 ext_1; mov $1v_2 ext_2; mov $1v_3 ext_3
#! ld1	{$1v.16b}, $2ea -> mov $1v_0 $2ea[+0]; mov $1v_1 $2ea[+4];\nmov $1v_2 $2ea[+8]; mov $1v_3 $2ea[+12]
#! ld1	{$1v.4s}, $2ea -> mov $1v_0 $2ea[+0]; mov $1v_1 $2ea[+4];\nmov $1v_2 $2ea[+8]; mov $1v_3 $2ea[+12]
#! mov d19, $1v.d\[1\] -> mov v19_0 $1v_2; mov v19_1 $1v_3; mov v19_2 0@uint32; mov v19_3 0@uint32
#! mov $1v.d\[1\], $2v.d\[0\] -> mov $1v_2 $2v_0; mov $1v_3 $2v_1
#! rev32 $1v.16b, $2v.16b -> spl s10 s00 $2v_0 16; spl s08 s00 s00 8; spl s18 s10 s10 8;\njoin t10 s00 s08; join t00 s10 s18; join $1v_0 t10 t00;\nspl s10 s00 $2v_1 16; spl s08 s00 s00 8; spl s18 s10 s10 8;\njoin t10 s00 s08; join t00 s10 s18; join $1v_1 t10 t00;\nspl s10 s00 $2v_2 16; spl s08 s00 s00 8; spl s18 s10 s10 8;\njoin t10 s00 s08; join t00 s10 s18; join $1v_2 t10 t00;\nspl s10 s00 $2v_3 16; spl s08 s00 s00 8; spl s18 s10 s10 8;\njoin t10 s00 s08; join t00 s10 s18; join $1v_3 t10 t00
#! sli $1v.4s, $2v.4s, $3c -> split dc slil $2v_0 (32-$3c); shl slih slil $3c;\nsplit dc $1v_0 $1v_0 $3c; or $1v_0@uint32 slih $1v_0;\nsplit dc slil $2v_1 (32-$3c); shl slih slil $3c;\nsplit dc $1v_1 $1v_1 $3c; or $1v_1@uint32 slih $1v_1;\nsplit dc slil $2v_2 (32-$3c); shl slih slil $3c;\nsplit dc $1v_2 $1v_2 $3c; or $1v_2@uint32 slih $1v_2;\nsplit dc slil $2v_3 (32-$3c); shl slih slil $3c;\nsplit dc $1v_3 $1v_3 $3c; or $1v_3@uint32 slih $1v_3
#! st1 {$1v.4s}, $2ea -> mov $2ea $1v_0; mov $2ea[+4] $1v_1;\nmov $2ea[+8] $1v_2; mov $2ea[+12] $1v_3
#! st1 {$1v.4s, $2v.4s}, $3ea -> mov $3ea $1v_0; mov $3ea[+4] $1v_1;\nmov $3ea[+8] $1v_2; mov $3ea[+12] $1v_3;\nmov $3ea[+16] $2v_0; mov $3ea[+20] $2v_1;\nmov $3ea[+24] $2v_2; mov $3ea[+28] $2v_3
#! ushr $1v.4s, $2v.4s, $3c -> split $1v_0 dc $2v_0 $3c; split $1v_1 dc $2v_1 $3c;\nsplit $1v_2 dc $2v_2 $3c; split $1v_3 dc $2v_3 $3c
#! mul $1v.16b, $2v.16b, $3v.16b -> mull %$dc %$1v %$2v %$3v
#! mul $1v.8h, $2v.8h, $3v.8h -> mull %$dc %$1v %$2v %$3v
#! mul $1v.4s, $2v.4s, $3v.4s -> mull %$dc %$1v %$2v %$3v
#! sqrdmulh $1v.4s $2v.4s $3v.4s -> smull %L0 %L1 %$2v %$3v;\n usplit %L00 %dc %L0 31;\n cast %L01@sint32 %L00;\n add %$1v_0 %L1 %L01;